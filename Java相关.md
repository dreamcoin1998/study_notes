[toc]

# 继承Thread类

实现多线程编程的方式主要有两种，一种是继承Thread类，另一种是实现Runnable接口

因为Thread类实现了Runnable接口，又因为Java是单根继承，所以通过继承Thread类的方式实现多项成的最大的局限是不支持多继承。

- **单根继承**：Java中，所有的类都继承自一个基类，即Object。
- **Java不支持多继承**：在Java中不支持多继承class，而支持多继承interface

Thread.java类中的start()方法通知“线程规划器”此线程已准备就绪，等待调用线程对象的run()方法，其实就是让系统安排一个时间来调用run()方法，使线程得到执行，启动线程，具有异步执行的效果，如果调用代码thread.run方法就不是异步执行了，而是由主线程同步执行run()方法，必须等run()方法中的代码执行完毕后才能执行后面的方法。

# 实现Runnable接口

如果欲创建的多线程已经有一个父类了，这个时候就不能够再继承Thread类了，因为Java不支持多继承，这个时候就需要实现Runnable接口来应对这种情况。

**使用继承Thread的方法实现多线程是存在局限性的，所以为了改变这种限制，可以使用实现Runnable接口的方式来实现多线程技术**

# 实例变量与线程安全

自定义线程类中的实例变量针对其他线程有**共享**与**不共享**之分。

*对有些 JVM 来讲，i--操作分为三步：取得 i 值 、计算 i-1、对 i 赋值*

在以上三个步骤中，如果多个线程同时访问，一定会出现非线程安全问题

**通过在run方法前加上synchronized关键字，使得多个线程在执行run方法时，以排队的形式进行处理。**

synchronized可以在任意对象或方法前加锁，被加锁的这段代码称为“互斥区”或“临界区”。

**非线程安全**：指多个线程对同一个值对象中的一个实例变量进行操作时会出现值被更改，值不同步的情况，进而影响程序执行的流程。

### 静态方法和实例方法的区别

在外部调用静态方法时，可以使用“类名.方法名”的形式也可以使用“对象名.方法名”的形式调用，使用静态方法时无需创建对象。静态方法在访问本类成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法，实例方法无限制。

### @Override

这个是伪代码表示重写，不写也可以，可以当注释用，方便阅读；

可以验证父类中是否由此方法，如果没有会报错。

# currentThread()方法

currentThread()方法可返回代码段正在被哪个线程调用的信息。



# isAlive()方法

判断当前线程是否处于活动状态

**活动状态**：活动状态就是线程已经启动并且尚未终止，线程处于正在运行或准备开始的状态，就认为线程是存活的。





















